# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'C:\Users\GAndoo\Desktop\test.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import xlrd
import PyQt5
from PyQt5 import QtWidgets
from PyQt5 import QtCore, QtGui, QtWidgets
import cv2
import numpy as np
import imutils
import os
from os import listdir
import time
from os.path import isfile, join
from PyQt5.QtCore import pyqtSignal, QObject
from PyQt5.QtCore import QThread
from PyQt5.QtWidgets import QMessageBox
stop_flag = 0
import sys

photos_path_string = ""
hand_image_path_string = ""
dimensions_file_path_string = ""

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(811, 450)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.start_button = QtWidgets.QPushButton(self.centralwidget)
        self.start_button.setGeometry(QtCore.QRect(330, 180, 93, 28))
        self.start_button.setObjectName("start_button")
        self.start_button.clicked.connect(self.start_thread)
        self.progress = QtWidgets.QProgressBar(self.centralwidget)
        self.progress.setGeometry(QtCore.QRect(50, 230, 711, 23))
        self.progress.setProperty("value", 0)
        self.progress.setObjectName("progress")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(30, 50, 91, 16))
        self.label.setObjectName("label")
        self.photos_path = QtWidgets.QLineEdit(self.centralwidget)
        self.photos_path.setGeometry(QtCore.QRect(120, 50, 241, 22))
        self.photos_path.setObjectName("photos_path")

        self.datafile_path = QtWidgets.QLineEdit(self.centralwidget)
        self.datafile_path.setGeometry(QtCore.QRect(120, 150, 241, 22))
        self.datafile_path.setObjectName("datafile_path")

        self.hand_path = QtWidgets.QLineEdit(self.centralwidget)
        self.hand_path.setGeometry(QtCore.QRect(120, 100, 241, 22))
        self.hand_path.setObjectName("hand_path")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(40, 100, 81, 16))
        self.label_2.setObjectName("label_2")

        self.label_5 = QtWidgets.QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(40, 150, 81, 16))
        self.label_5.setObjectName("label_5")

        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(350, 270, 111, 16))
        self.label_3.setObjectName("label_3")



        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 811, 25))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Gems-pasting"))
        self.start_button.setText(_translate("MainWindow", "Start"))
        self.label.setText(_translate("MainWindow", "Photos folder:"))
        self.label_2.setText(_translate("MainWindow", "Hand photo:"))
        self.label_3.setText(_translate("MainWindow", "Idle..."))
        self.label_5.setText(_translate("MainWindow", "Data file:"))


    def start_thread(self):

        global photos_path_string,dimensions_file_path_string,hand_image_path_string
        self.thread = work_thread()

        photos_path_string = process_path(self.photos_path.text())
        hand_image_path_string = process_path(self.hand_path.text())
        dimensions_file_path_string = process_path(self.datafile_path.text())





        self.thread.progress_value.connect(self.update_progress)
        self.thread.start()
        self.label_3.setText("Processing...")



    def update_progress(self,val):
        self.progress.setProperty("value", val)

        if(val == 100):
            self.label_3.setText("Done...")





kernel = np.ones((5, 5), np.uint8)

def read_dimensions(stone_id,sheet):

    for i in range(1,sheet.nrows):
        if (sheet.cell_value(i, 1) == stone_id):
            length = sheet.cell_value(i, 5)
            width = sheet.cell_value(i,6)
            ##print("Length: ",length)
            #("width: ",width)
            return (1,length,width)

    return (0,0,0)

def process_path(inp):
    inp = inp.replace("\\", "\\\\")
    return inp
def maintain_aspect_ratio_resize(image, width=None, height=None, inter=cv2.INTER_AREA):
    # Grab the image size and initialize dimensions
    dim = None
    (h, w) = image.shape[:2]

    # Return original image if no need to resize
    if width is None and height is None:
        return image

    # We are resizing height if width is none
    if width is None:
        # Calculate the ratio of the height and construct the dimensions
        r = height / float(h)
        dim = (int(w * r), height)
    # We are resizing width if height is none
    else:
        # Calculate the ratio of the 0idth and construct the dimensions
        r = width / float(w)
        dim = (width, int(h * r))

    # Return the resized image
    return cv2.resize(image, dim, interpolation=inter)

def load_file(path):
    loc =path

    wb = xlrd.open_workbook(loc)
    sheet = wb.sheet_by_index(0)

    # For row 0 and column 0
    sheet.cell_value(0, 0)
    return sheet
def find_clr(img):
    data = np.reshape(img, (-1, 3))
    # print(data.shape)
    data = np.float32(data)

    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
    flags = cv2.KMEANS_RANDOM_CENTERS
    compactness, labels, centers = cv2.kmeans(data, 1, None, criteria, 10, flags)

    # print(sum(centers[0])/(3))
    return (sum(centers[0]) / (3))


def creating_mask(image, clr):
    global threshold
    image = image.copy()
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # (T, image) = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)
    image = cv2.GaussianBlur(image, (5, 5), 0)

    canny = cv2.Canny(image, 10, 20)
    canny = cv2.dilate(canny, kernel, iterations=1)
    (cnts, _) = cv2.findContours(canny.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cntsSorted = sorted(cnts, key=lambda x: cv2.contourArea(x))

    # cv2.drawContours(canvas, cntsSorted, len(cntsSorted) - 1, red, 2)

    # print("Mask shape:",canny.shape)
    mask = np.zeros(canny.shape, np.uint8)
    cv2.drawContours(mask, cntsSorted, len(cntsSorted) - 1, (255), -1)

    # cv2.imshow("Mask", mask)
    cv2.imwrite("mask.png", mask)
    # cv2.waitKey(0)
    return mask


def draw_outer_contour(temp):
    global threshold
    canvas = temp.copy()
    # print("Area",canvas.shape)
    temp = cv2.cvtColor(temp, cv2.COLOR_BGR2GRAY)
    # (T, temp) = cv2.threshold(temp, threshold, 255, cv2.THRESH_BINARY)

    temp = cv2.GaussianBlur(temp, (5, 5), 0)

    canny = cv2.Canny(temp, 30, 50)
    canny = cv2.dilate(canny, kernel, iterations=1)
    # cv2.imshow("temp", canny)
    # cv2.waitKey(0)
    red = (0, 0, 255)
    (cnts, _) = cv2.findContours(canny.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    cntsSorted = sorted(cnts, key=lambda x: cv2.contourArea(x))

    # cv2.drawContours(canvas, cntsSorted, len(cntsSorted) - 1, red, 2)
    # cv2.imshow("Contours:",canvas)
    # cv2.waitKey(0)

    return (cntsSorted[len(cntsSorted) - 1])


def process_cropped(image):
    cropped = image.copy()
    (h, w, c) = cropped.shape
    offset = -5
    flipped = cv2.flip(cropped, 1)
    cv2.imshow("flipped:", flipped)
    left = cropped[0:h, 0:int(w / 2 + offset)]
    right = cropped[0:h, int(w / 2 + offset):w]

    cropped[0:h, int(w / 2 + offset):w] = flipped[0:h, int(w / 2 + offset):w]
    m_copy = cropped.copy()
    cv2.line(m_copy, (int(w / 2 + offset), 0), (int(w / 2 + offset), h), (0, 0, 255), 1)
    cv2.imshow("Colored:", m_copy)
    cv2.waitKey(0)


def process_mask(mask):
    (h, w) = mask.shape
    offset = 0
    flipped = cv2.flip(mask, 1)

    left = mask[0:h, 0:int(w / 2 + offset)]
    right = mask[0:h, int(w / 2 + offset):w]

    left_px = cv2.countNonZero(left)
    right_px = cv2.countNonZero(right)

    # print(left_px,right_px)
    # print(abs(left_px-right_px))

    if (abs(left_px - right_px) > 10):
        # print("changing mask")
        mask[0:h, int(w / 2):w] = flipped[0:h, int(w / 2):w]
    m_copy = mask.copy()
    # cv2.line(m_copy, (int(w / 2 +offset), 0), (int(w / 2 +offset), h), (0), 1)
    # cv2.imshow("Line:",m_copy)
    # cv2.waitKey(0)
    return mask
    #


def paste_image(image,hand_image,stone_l,stone_w,width_ratio):
    #gem = cv2.imread(image)
    gem = image
    (x, y, w, h) = cv2.boundingRect(draw_outer_contour(gem))

    offset = 30
    cropped = gem[y - offset:y + h + offset, x - offset:x + w + offset]
    #cv2.imshow("Cropped", cropped)
    #cv2.waitKey(0)
    clr = (find_clr(cropped))
    mask = creating_mask(cropped,clr)

    width = int(width_ratio*stone_w)+12
    cropped = maintain_aspect_ratio_resize(cropped, width=width)

    mask = maintain_aspect_ratio_resize(mask, width=width)

    cropped =  imutils.translate(cropped, 2, 0)
    #cv2.imshow("Before:",mask)
    #process_cropped(cropped)
    mask = imutils.translate(mask, 2, 0)
    mask = process_mask(mask)
    #cv2.imshow("After:",mask)
    #cv2.waitKey(0)
    (th, tw, tc) = cropped.shape
    #cropped_cpy = cropped.copy()

    #ofs = 0
    #cv2.line(cropped_cpy,(int(tw / 2 +ofs), 0), (int(tw / 2 +ofs),th), (0,0,255), 1)
    #cv2.imshow("cropped",cropped_cpy)
    #cv2.imwrite("offset_testing.png",cropped_cpy)
    #cv2.waitKey(0)
    background = cv2.imread(hand_image)

    alpha_channel = np.zeros((background.shape[0], background.shape[1]), np.uint8)
    x = 683
    y = 671

    x = int(x - tw / 2)
    y = int(y - th / 2)


    dummy = np.zeros(background.shape, np.uint8)
    dummy[y:y + th, x:x + tw] = cropped
    alpha_channel[y:y + th, x:x + tw] = mask

    foreground = dummy

    background = background
    cv2.imwrite("alpha_channel.png", alpha_channel)

    alpha_channel = cv2.imread("alpha_channel.png")
    alpha = alpha_channel / 255
    # alpha = alpha_channel.astype(np.uint8)
    # cv2.imshow("alpha",alpha)

    # cv2.waitKey(0)
    # Multiplyalpha = alpha_channel / 255 the foreground with the alpha matte

    foreground = cv2.multiply(alpha, foreground, dtype=cv2.CV_8U)

    # Multiply the background with ( 1 - alpha )

    background = cv2.multiply(1.0 - alpha, background, dtype=cv2.CV_8U)

    # Add the masked foreground and background.

    outImage = cv2.add(foreground, background)

    # Display image
    return outImage


'''

'''


class work_thread(QThread):

    def __init__(self, parent = None):
        super(work_thread,self).__init__(parent)
    progress_value = pyqtSignal(int)


    def run(self):
        self.count = 0
        self.start_working()




    def start_working(self):

        global photos_path_string,hand_image_path_string,dimensions_file_path_string
        #self.label_3.setText("Processing...")
        output_path = "output_images\\"
        
        if not os.path.exists(output_path):
            os.makedirs(output_path)

        path = photos_path_string

        hand_image = hand_image_path_string


        # C:\Users\GAndoo\OneDrive\PHOTOS
        # C:\Users\GAndoo\Desktop\robot_control\hand.png
        file_path = dimensions_file_path_string
        #path = "C:\\Users\\GAndoo\\Desktop\\photos\\PHOTOS\\"
        onlyfiles = [f for f in listdir(path) if isfile(join(path, f))]

        #sheet = load_file(file_path)
        sheet = load_file(dimensions_file_path_string)
        counter = 0

        for file in ((onlyfiles)):

          ok = 1

          try:
                stone_id = int(file.split(" ")[0])
          except:
                ok = 0

          if (ok):

            (f, stone_length, stone_width) = read_dimensions(stone_id, sheet)
            print(file)
            #QtCore.QCoreApplication.processEvents()
            # print("Image:",path+file)


            try:
                image = cv2.imread(path + file)
                #(image_h, image_w, c) = hand_image.shape
                (orig_h, orig_w, c) = image.shape

                length_ratio = 117 / 16.5
                width_ratio = 117 / 16.5
                #print("LENGTH/WIDTH RATIOS: ", length_ratio, width_ratio)
                image = cv2.resize(image, (int(orig_h / 3), int(orig_w / 3)), interpolation=cv2.INTER_AREA)
                image = imutils.rotate(image, 90)

                outImage = paste_image(image, hand_image, stone_length, stone_width, width_ratio)
                #cv2.imshow("image",outImage)
                #cv2.waitKey(0)
                cv2.imwrite(output_path + "\\\\" + file, outImage)

            except Exception as e:
                print("ERROR:")
                print(e)

            #
            #



          counter += 1

          self.progress_value.emit(int(counter * 100 / len(onlyfiles)))






def my_excepthook(type, value, tback):
    # log the exception here

    # then call the default handler
    sys.__excepthook__(type, value, tback)


'''if __name__ == "__main__":


    sys.excepthook = my_excepthook
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec())
'''

if __name__ == '__main__':
 try:
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec())
 except:
     print("THAAN")
     